%Gauss Seidal Method for Load Flow Analysis
clc
bus = input('Enter the number of buses in the system: ');
lines = input('Enter the number of lines the system has: ');
fprintf('\n')

%Take the initial guess voltages for the buses
V_initial = zeros(1,bus);
for k = 1:1:bus
   if k ~= 1
       fprintf('For bus: %i',k)  
       V_initial(k) = input('\nWhat is the initial voltage of the bus? ');
   else
      V_initial(k)= input('What is the slack bus voltage in rectangular form? ');
   end    
end

%Take the power generated by the various buses
P_gen = zeros(1,bus);
for g = 1:1:bus
    if g ~= 1
       fprintf('For bus: %i',g) 
       P_gen(g) = input('\nWhat is the power generated at this bus? ');
    else
        P_gen(g) = 0;
    end   
end

%Take the power demand on each generator bus
P_load = zeros(1,bus);
for l = 1:1:bus
    fprintf('For bus: %i',l) 
    P_load(l) = input('\nWhat is the load demand at this bus? ');    
end

P_injected = zeros(1,bus);
for m = 1:1:bus
    P_injected(m)=P_gen(m)-P_load(m);
end

Y = zeros(bus,bus);
%The sending and ending bus numbers are requested for as well as the
%impedance using a for loop. In the if statement, once the sending bus is
%not equal to the ending bus, the admittance is negated.
for k = 1:1:lines
   SB = input('Enter the sending bus number: ');
   EB = input('Enter the ending bus number:  ');
   y = input('Enter the admittance of the line: ');
   if SB~=EB
      Y(SB,EB) = -y;
      Y(EB,SB) =  Y(SB,EB);
   end
   fprintf('\n')
end
%Add all the row y elements and store the in position (y,y) of the matrix 
for y = 1:1:bus
    for i = 1:1:bus  
        if y~=i
            Y(y,y) = Y(y,y) + Y(y,i);  
        end
    end
    Y(y,y) = -Y(y,y);
    
end

%Gauss Seidal algorithm
V_cal = zeros(1,bus);
V_initials = zeros(1,bus);
    for t = 1:1:bus
        V_initials(t) = V_initial(t);
      
    end
for q = 1:1:bus
    Z=0;
   if q ~= 1
          for i = 1:1:bus
              
               if i ~= q
                   Z = Z + (Y(q,i) * V_initial(i));
               end
           end
          
   V_cal(q) = (1/Y(q,q)) * (P_injected(q)'/V_initial(q)' - Z);     
   V_initial(q) = V_cal(q);
   else
       
       V_cal(q) = V_initial(q);
       
   end
       
end
V_cal
V_diff = zeros(1,bus);

      for f = 2:1:bus
   V_diff = abs(V_cal - V_initials);
      end
        for d = 2:1:bus
            V_initials(d) = V_cal(d);
        end
        for x = 2:1:bus
    while real(V_diff(x))||imag(V_diff(x)) >= 0.001
        for b = 2:1:bus
     V_diff(x) = abs(V_cal(x) - V_initials(x));
        end
        for d = 2:1:bus
            V_initials(d) = V_cal(d);
        end
        for q = 1:1:bus
    Z=0;
   if q ~= 1
          for i = 1:1:bus
              
               if i ~= q
                   Z = Z + (Y(q,i) * V_initial(i));
               end
           end
          
   V_cal(q) = (1/Y(q,q)) * (P_injected(q)'/V_initial(q)' - Z);  
    V_initial(q) = V_cal(q);
   V_cal
   else
       
       V_cal(q) = V_initial(q);
       
   end
        end 
    end
       end    
 V_cal    
    










